# 📚 15장 디자인 패턴과 프레임워크 

- 디자인 패턴 
  - 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법
  - 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿 제공
  - 목적
    - 설계를 재사용
    - 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음 

- 프레임 워크
  - 설계와 코드를 함께 재사용하기 위한 것
  - 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다. 
  - 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공

## 📖 15.1 디자인 패턴과 설계 재사용

### 🔖 15.1.1 소프트웨어 패턴

- 패턴의 몇가지 핵심적인 특징
1. 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
2. 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할수 있으며, 이 지식을 다른 사람과 의사소통 할수 있다.
3. 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
4. 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

- 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 '아이디어'다.
- 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 잇다는 점
  - 패턴은 경험의 산물이다.
- 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 떄문에 패턴에서 가장 중요한 요소는 패턴의 '이름'이다.
  - 패턴의 이름은 높은 수준의 대화를 가능하게 하는 원천이다.
- 패턴은 홀로 존재 하지 않는다.
  - 특정 패턴내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더작은 패턴에 의해 서술 될수 있으며 패턴들을 포한하는 더 큰 패턴 내에 통합될 수 있다.
  - 연관된 패턴들의 집합들이 모여 하나의 패턴 언어 를 구성한다.

### 🔖 15.1.2 패턴 분류

패턴을 분류하는 가장 일반적인 방법은 패턴의 범위나 적용 단계에 따라 아키텍처 패턴 , 분석 패턴, 디자인 패턴, 이디엄 4가지로 분류

- 디자인 패턴
  - 특정 정화 내에서 일반적인 설계 문제 해결
  - 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술
  - 중간 규모의 패턴
  - 프로그래밍 언어나 프로그래밍 패러다임에 독립적

- 아키텍처 패턴
  - 디자인 패턴의 상위
  - 소프트웨어의 전체적인 구조를 결정하기 위해 사용
  - 미리 정의된 서브시스템들을 제공 , 각 서브 시스템들의 책임을 정의 , 서스시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함
  - 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공

- 이디엄
  - 디자인패턴의 하위
  - 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴 
  - 주어진 언어의 기능을 사용해 컴포넌트 , 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술
  - 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될수 있다.

- 분석패턴
  - 도메인 내의 개념적인 문제를 해결하는 데 초점
  - 업무 모델링 시에 발견되는 공톡적인 구조를 표현하는 개념들의 집합

### 🔖 15.1.3 패턴과 책임-주도 설계

객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일이다.
책임과 협력의 윤곽은 캡슐화, 크기 , 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 요소들의 트레이드오프를 통해 결정된다.

패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.

STRATEGY 패턴 - 다양한 알고리즘을 동적으로 교체 할수 있는 역할과 책임의 집합
BRIDGE 패턴 - 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 역할과 책임을 추상화와 구현으로 분리
OBSERVER 패턴 - 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공

패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실

특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임,
협력 관계를 빠르고 손쉽게 구성

패턴의 구성 요소는 클래스가 아니라 '역할' 이다.
- 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시한다.
- 역할, 책임, 협력의 관점에서 유사성을 공유한다는것이지 특정 구현 방식을 강제하는것이 아니다.
  - 제안만 할뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.

### 🔖 15.1.4 캡슐화와 디자인 패턴

STARATEGY 패턴의 목적은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.
![image](https://github.com/bithumb-study/study-object/assets/58027908/f3158f44-2b77-4b8b-89a4-9cd27208ad6e)

TEMPLATE METHOD 패턴은 알고리즘을 캡슐화하기 위해 합설 관계가 아닌 상속 관계를 이용하는 것
- 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화 할 수 있는 디자인 패턴
추상 클래스나 인터페이스를 사용해 변경을 캡슐화하는 합성과 달리 상속을 사용할 경우에는 추상 메서드를 이용해 변경을 캡슐화 해야 한다.

![image](https://github.com/bithumb-study/study-object/assets/58027908/99b9c43c-5eb2-4070-b534-669356c1aa3e)

DECORATOR 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로써 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다.
선택적인 행동의 개수와 순서에 대한 변경을 캡슐화 할수 있다.

![image](https://github.com/bithumb-study/study-object/assets/58027908/d4fbf8af-f242-43c8-ba75-cb25f8a3d70b)

### 🔖 15.1.5 패턴은 출발점이다.

- 패턴은 출발점이지 목적지가 아니다.
- 패턴은 설계의 목표가 돼서는 안된다.
- 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 맞지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.

패턴 만능주의
- 패턴을 사용하면서 부딪히게 되는 대부분의 문제는 패턴을 맹목적으로 사용할 때 발생한다. 

패턴을 남용하지 않기 위해서는 다양한 트레이드오프 관계 속에서 패턴을 적용하고 사용해 본 경험이 필요하다.

정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다.

패턴은 복잡성의 가치가 단순성을 넘어설때만 정당화 돼야 한다. 

패턴을 가장 효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링하는 것이다.

## 📖 15.2 프레임워크와 코드 재사용

### 🔖 15.2.1 코드 재사용 대 설계 재사용

재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다.

가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다.

프레임워크 - 코드를 재사용함으로써 설계 아이디어를 재사용한다.
- 구조적인 측면 
  - 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계\
- 코드와 설계의 재사용이라는 프레임워크의 사용 목적
  - 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격

### 🔖 15.2.2 상위 정책과 하위 정책으로 패키지 분리하기

프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화라고 할수 있다.

추상 클래스와 인터페이스가 일관성 있는 협력을 만드는 핵심 재료
협력을 일관성 있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 캡슐화 해야한다.
협력을 구현하는 코드 안의 의존성은 가급적이면 추상 클래스나 인터페이스와 같은 추상화를 향하도록 작성해야한다.

상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경 된다.
- 만약 변하지 않는 상위 정책이 자주 변하는 세부 사항에 의존한다면 변경에 대한 파급효과로 인해 상위 정책이 불안정해 질것이다.
- 상위 정책이 세부 사항에 비해 재사용될 가능성이 높다.

의존성 역전 원칙에 맞게 상위 정책과 세부 사항 모두 추상화에 의존하게 만드는것이다.

의존성 역전 원칙의 관점에서 세부 사항은 변경을 의미한다.

동일한 역할을 수행하는 객체들 사이의 협력 구조를 다양한 애플리케이션 안에서 재사용하는 것이 핵심
- 이를 위해서는 변하는 것과 변하지 않는 것을 서로 분리해야 한다.
  - 변하지 않는것은 상위 정책에 속하는 역할들의 협력 구조
  - 변하는 것은 구체적인 세부사항

프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할수 있도록 
별도의 배포 단위로 분리해야 한다.

변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는것이다.

![image](https://github.com/bithumb-study/study-object/assets/58027908/a5c5958d-5a7a-4982-bfae-141840fcfb76)

중요한 것은 패키지 사이의 의존성 방향이다.

의존성 역전 원리에 따라 추상화에만 의존하도록 의존성 방향을 조정하고 추상화를 경계로 패키지를 분리했기 때문에 세부 사항을 구현한 패키지는
항상 상위 정책을 구현한 패키지에 의존해야 한다.

좀더 나아가 상위 정책을 구현하고 있는 패키지가 충분히 안정적이고 성숙했다면 하위 정책 패키지로 부터 완벽히 분리해서 별도의 배포 단위로 만들수 있다.

### 🔖 15.2.3 제어 역전 원리

의존성 역전 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리이다.

좋은 객체지향 설계의 증명은 바로 이와 같은 의존성 역전이다.

프로그램 의존성이 역전돼 있다면 이것은 객체지향 설계를 갖는 것이다.

- 제어 역전 원리 , 할리우드 원리
  - 의존성을 역전시킨 객체지향 구조에서는 반대로 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출한다. 
  - 즉 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다.

- 훅
  - 프레임워크에서 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질수 있는 특정한 동작
  - 프레임워크 코드에서 호출하는 프레임워크의 특정 부분
  - 제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출한다.

- 제어 역전
  - 우리는 프레임워크가 적절한 시점에 실행할 것으로 예상되는 코드를 작성할 뿐이다.
  - 과거에는 우리가 직접 라이브러리의 코드를 호출했지만 객체지향의 시대에는 그저 프레임워크가 호출하는 코드를 작성해야만 한다.
  - 제어가 우리에게서 프레임워크로 넘어가 버린 것이다.

